-----

原文链接：https://www.geeksforgeeks.org/solve-dynamic-programming-problem/

时间：20190530

译者：BING

----

**动态规划**（DP）是一种在多项式时间复杂度解决特定问题的技术。动态规划方法比指数级暴力搜索方法要快且能很容易证明正确性。在学习如何动态思考问题之前，我们需要先学习：

1. [重叠子问题](https://www.geeksforgeeks.org/dynamic-programming-set-1/)
2. [最优子结构属性](https://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/)

```json
解决DP问题的步骤
1) 识别问题是不是DP问题
2) 用最少的参数确定一个状态表达式
3) 用公式表达状态关系
4) 打表(或者添加记忆)
```

**步骤1：如何将问题划分为动态规划问题？**

- 一般来书，要求最大化/最小化特定数值或者计数问题，比如在特定条件下或者在特定概率下计算安排的数量问题就能用DP来解决。
- 所有的动态规划问题都需要满足重叠子问题特性，且大部分的经典动态规划问题也满足最优子结构特性。如果我们在问题中发现了这些特定，很确定，这个问题可以用DP来解决。

**步骤2：决定状态表示**

DP问题就是关于状态和状态的转移。这是最基础的步骤，需要我们小心解决，因为状态转移方程依赖我们对状态的定义。因此，我们先看看什么是状态。

**状态**：状态可以定义为一组参数，这组参数能够唯一确定给定问题的定位。这组参数应当尽量少，以减少状态空间。

比如，在经典的[背包问题](https://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/),中，我们用两个参数来定义状态：`index`和`weight`。`index`告诉我们最大化收益能从0到`index`之间选择物品。因此`index`和`weight`能唯一确定背包子问题。

因此，在确定问题是DP问题后，我们第一步需要决定问题的状态定义。

我们知道DP问题就是使用中间计算结果来推导最后的结果。因此我们下一步就需要寻找上一个状态到当前状态的关系。

**步骤3：公式化状态之间关系**
这部分是解决DP问题最难的部分，需要大量的直觉，观察和练习。我们通过样本问题来理解：

```bash
给定3个数字，{1, 3, 5}，我们需要计算出组成数字N的所有的方式，对给定的三个数字使用加法（允许重复和不同的组织）。

所有的能加和为6的方法有：8种

1+1+1+1+1+1
1+1+1+3
1+1+3+1
1+3+1+1
3+1+1+1
3+3
1+5
5+1
```

我们动态的思考这个问题。首先，我们需要确定给定问题的状态定义。我们使用一个参数来确定状态，它能唯一确认任何子问题。因此，我们的状态DP将像这样`state(n)`。这里，`state(n)`表示使用{1, 3, 5}作为元素能组成n的所有方式。

现在我们来计算`state(n)`。

**怎么做？**

这里直觉就很有用。我们可以使用1，3，5来组成给定的数字。假定我们知道n=1,2,3,4,5,6的结果，即我们知道`state(n=1)`，`state(n=2)`...`state(n=6)`的值。

现在我们希望知道`state(n=7)`的结果。我们只能加1，3和5。现在我们能得到加和为7，通过下面三种方法：

**1)  加1到`state(n=6)`中所有的组合：**
如 : [ (1+1+1+1+1+1) + 1]
[ (1+1+1+3) + 1]
[ (1+1+3+1) + 1]
[ (1+3+1+1) + 1]
[ (3+1+1+1) + 1]
[ (3+3) + 1]
[ (1+5) + 1]
[ (5+1) + 1]

**2) 加3到所有的`state(n=4)`的组合：**

如 : [(1+1+1+1) + 3]
[(1+3) + 3]
[(3+1) + 3]

**3) 加5到所有`state(n=2)`的组合：**
如 : [ (1+1) + 5]

现在仔细想想，上面三种情况基本覆盖了所有的组成7的方式。

因此，我们能说`state(7) = state(6) + state(4) + state(2)`或者，

`state(7) = state(7-1) + state(7-3) + state(7-5)`

总体来说，

**state(n) = state(n-1) + state(n-3) + state(n-5)**

因此我们的代码看起来像下面这样：

```c++
// 返回形成n的所有组合可能
int solve(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 0) {
        return 1;
    }
    return solve(n-1) + solve(n-3) + solve(n-5);
}
```

上面的代码看起来是指数级别的，因为它不停的计算相同的状态。因此，我们只需要添加记忆化即可。

**步骤4：添加记忆化或者表格化这些状态**

这是DP问题最容易的部分。我们只需要存储状态，下一次这个状态需要时，我们直接从存储中取出来即可。

为上面的代码添加记忆化：

```c++
// initialize to -1 初始化为-1
int dp[MAXN];
// 这个函数返回组成n的所有方式
int solve(int n) {
	if (n < 0) {
        return 0;
    } 
    if (n == 0) {
        return 1;
    }
    // 检查是否计算过
    if (dp[n] != -1) {
        return dp[n];
    }
    return dp[n] = solve(n-1) + solve(n-3) + solve(n-5);
}
```

另一种方式就是添加表格并使问题迭代化。请看这篇 [表格化和记忆化](https://www.geeksforgeeks.org/tabulation-vs-memoizatation/)了解更多细节。

动态规划需要大量的练习。必须先尝试解决经典DP问题，可以参考[这里](https://www.geeksforgeeks.org/fundamentals-of-algorithms/#DynamicProgramming)，你可以先看看下面的问题，然后尝试使用上面的步骤来解决问题：

- [http://www.spoj.com/problems/COINS/](http://www.spoj.com/problems/COINS/)
- [http://www.spoj.com/problems/ACODE/](http://www.spoj.com/problems/ACODE/)
- https://www.geeksforgeeks.org/dynamic-programming-set-6-min-cost-path/
- https://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/
- https://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/
- https://www.geeksforgeeks.org/dynamic-programming-set-5-edit-distance/

本文由 [**Nitish Kumar**](https://www.linkedin.com/in/nk17kumar/)贡献。

#### 推荐文章：

- [Overlapping Subproblems Property in Dynamic Programming | DP-1](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)
- [Optimal Substructure Property in Dynamic Programming | DP-2](https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/)
- [0-1 Knapsack Problem | DP-10](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)
- [Word Wrap Problem | DP-19](https://www.geeksforgeeks.org/word-wrap-problem-dp-19/)
- [Partition problem | DP-18](https://www.geeksforgeeks.org/partition-problem-dp-18/)
- [Box Stacking Problem | DP-22](https://www.geeksforgeeks.org/box-stacking-problem-dp-22/)
- [Subset Sum Problem | DP-25](https://www.geeksforgeeks.org/subset-sum-problem-dp-25/)
- [Largest Independent Set Problem | DP-26](https://www.geeksforgeeks.org/largest-independent-set-problem-dp-26/)
- [Word Break Problem | DP-32](https://www.geeksforgeeks.org/word-break-problem-dp-32/)
- [Travelling Salesman Problem | Set 1 (Naive and Dynamic Programming)](https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/)
- [Printing brackets in Matrix Chain Multiplication Problem](https://www.geeksforgeeks.org/printing-brackets-matrix-chain-multiplication-problem/)
- [Boolean Parenthesization Problem | DP-37](https://www.geeksforgeeks.org/boolean-parenthesization-problem-dp-37/)
- [Mobile Numeric Keypad Problem](https://www.geeksforgeeks.org/mobile-numeric-keypad-problem/)
- [Vertex Cover Problem | Set 2 (Dynamic Programming Solution for Tree)](https://www.geeksforgeeks.org/vertex-cover-problem-set-2-dynamic-programming-solution-tree/)
- [Tiling Problem](https://www.geeksforgeeks.org/tiling-problem/)

END.

