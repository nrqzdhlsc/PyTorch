----

原文链接：https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/

译者：BING

时间：20190602

----

动态规划是一种解决复杂问题的算法机制，通过将问题分解为子问题，并存储子问题的结果来避免重复计算，下面是判断给定问题能用动态规划来解题的两个性质：

本文中我们会细致讨论第一个性质(重叠子问题)，第二个性质会在下一篇文章中讨论。

1) 重叠子问题
2) 最优子结构

**1) 重叠子问题**

和分治法相似，动态规划会组合子问题的解。动态规划主要用在相同的子问题的解需要使用多次时。在动态规划中，计算出来的子问题的解会保存在表中，因此子问题无需再重复计算。因此在没有通用的子问题时，动态规划是无用的。比如，[二分搜索](https://www.geeksforgeeks.org/binary-search/)就没有通用的子问题，如果我们以下面的斐波那契数列递归解法为例，就有很多子问题，需要一遍又一遍地计算。

```c++
`/* simple recursive program for Fibonacci numbers */``int` `fib(``int` `n) ``{ ``   ``if` `( n <= 1 ) ``      ``return` `n; ``   ``return` `fib(n-1) + fib(n-2); ``}`
```

*fib(5)*的递归执行树：

```bash
                         fib(5)
                     /             \
               fib(4)                fib(3)
             /      \                /     \
         fib(3)      fib(2)         fib(2)    fib(1)
        /     \        /    \       /    \
  fib(2)   fib(1)  fib(1) fib(0) fib(1) fib(0)
  /    \
fib(1) fib(0)
```

我们可以看到`fib(3)`被调用了两次。如果我们已经存储了`fib(3)`的值，那么就无需重复计算，我们重用这个存储的值即可。**有两种不同的方式**来存储这些值以便这些值的重用：

**a) 记忆法(自顶向下)**

**b) 表格法(自底向上)**

**a) 记忆法 (自顶向下):** 记忆法的程序解法和递归版本的程序相似，只做了一点点小变动，会在计算前驱查表。我们初始化一个查找数组，给定一些空的初值。当我们需要子问题的结果时，我们首先查表。如果预先计算的值存在，我们就返回这个值，否则我们计算子问题的值然后将结果放入到表格中，以便后续重用。

下面是**记忆化版本**的第n个斐波那契数列的解法：

```c++
#include <bits/stdc++.h> 
using namespace std; 
#define NIL -1 
#define MAX 100 

int lookup[MAX]; 

// 初始化查询表，设置为-1
void _initialize() 
{ 
	int i; 
	for (i = 0; i < MAX; i++) 
		lookup[i] = NIL; 
} 

// 计算第n个斐波那契数列值
int fib(int n) 
{ 
	if (lookup[n] == NIL)  // 先判断表中有没有计算好的值
	{ 
		if (n <= 1) 
			lookup[n] = n; 
		else
			lookup[n] = fib(n - 1) + fib(n - 2); 
} 

	return lookup[n]; 
} 

// 驱动代码
int main () 
{ 
	int n = 40; 
	_initialize(); 
	cout << "Fibonacci number is " << fib(n); 
	return 0; 
} 

// 代码由Rathbhupendra贡献

```

**b) 表格法 (自底向上):** 表格化的程序会用自底向上的方法构建表格，并返回表格中的最新值。比如，同样是斐波那契数列，我们首先计算`fib(0)`然后`fib(1)`，然后是`fib(2)`，再然后是`fib(3)`等等。也就是说，我们会自底向上来计算子问题的解。

下面是表格法版本的斐波那契数列。

```c++
#incldue<stdio.h>
int fib(int n) {
    int f[n+1];
    int i;
    f[0] = 0; f[1] = 1;
    for (int i = 2; i < n; i++) {
        f[i] = f[i-1] + f[i-2];
    }
    return f[n];
}
int main() {
    int n = 9; 
    printf("Fibonacci number is %d ", fib(n));
}
```

输出:

```bash
 Fibonacci number is 34
```

表格法和记忆化方法都会存储子问题的解。记忆化版本中，表格会在需要时填充，而表格版本，会从第一个开始，逐条计算并填充表格。和表格法不同，在记忆法中，查询表中的条目并不会全部都填完。比如，记忆法版本的 [LCS问题 ](http://en.wikipedia.org/wiki/Longest_common_subsequence_problem)就没有填满查询表。

用记忆法和表格法实现对递归方法的优化，下面是计算第40个斐波那契数列的例子：

[递归解法](https://ide.geeksforgeeks.org/vHt6ly)
[记忆化解法](https://ide.geeksforgeeks.org/Z94jYR)
[表格解法](https://ide.geeksforgeeks.org/12C5bP)

使用递归解法消耗的时间要比两种动态规划技法长得多。

同样的，参考方法二对[丑数问题](https://www.geeksforgeeks.org/ugly-numbers/) 的解法，也具有重叠子问题，我们会保存子问题的结果。

我们将学习最优子结构性质，以及更多关于动态规划的案例。

试着练习求解下面的问题：

1) 写一个记忆化版本的LCS问题的解法，注意表格化的解法在CLRS（算法导论）书中已经给了。

2) 如何在记忆化和表格化两个之间进行选择呢？

## 推荐文章:

- [Optimal Substructure Property in Dynamic Programming | DP-2](https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/)
- [Dynamic Programming on Trees | Set 2](https://www.geeksforgeeks.org/dynamic-programming-trees-set-2/)
- [Bitmasking and Dynamic Programming | Set-2 (TSP)](https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/)
- [Dynamic Programming on Trees | Set-1](https://www.geeksforgeeks.org/dynamic-programming-trees-set-1/)
- [How to solve a Dynamic Programming Problem ?](https://www.geeksforgeeks.org/solve-dynamic-programming-problem/)
- [Top 20 Dynamic Programming Interview Questions](https://www.geeksforgeeks.org/top-20-dynamic-programming-interview-questions/)
- [Dynamic Programming vs Divide-and-Conquer](https://www.geeksforgeeks.org/dynamic-programming-vs-divide-and-conquer/)
- [Number of Unique BST with a given key | Dynamic Programming](https://www.geeksforgeeks.org/number-of-unique-bst-with-a-given-key-dynamic-programming/)
- [Greedy approach vs Dynamic programming](https://www.geeksforgeeks.org/greedy-approach-vs-dynamic-programming/)
- [Double Knapsack | Dynamic Programming](https://www.geeksforgeeks.org/double-knapsack-dynamic-programming/)
- [Dynamic Programming | Building Bridges](https://www.geeksforgeeks.org/dynamic-programming-building-bridges/)
- [Compute nCr % p | Set 1 (Introduction and Dynamic Programming Solution)](https://www.geeksforgeeks.org/compute-ncr-p-set-1-introduction-and-dynamic-programming-solution/)
- [Understanding The Coin Change Problem With Dynamic Programming](https://www.geeksforgeeks.org/understanding-the-coin-change-problem-with-dynamic-programming/)
- [Distinct palindromic sub-strings of the given string using Dynamic Programming](https://www.geeksforgeeks.org/distinct-palindromic-sub-strings-of-the-given-string-using-dynamic-programming/)
- [Travelling Salesman Problem | Set 1 (Naive and Dynamic Programming)](https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/)

END.