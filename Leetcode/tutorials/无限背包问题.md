----

原文链接：https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/

译者：BING

时间：20190602

----

Given a knapsack weight **W** and a set of **n** items with certain value *vali* and weight *wti*, we need to calculate minimum amount that could make up this quantity exactly. This is different from [classical Knapsack problem](https://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/), here we are allowed to use unlimited number of instances of an item.

给定一个背包，重量为W，并且一组n个物品，每个物品的值为`vali`，重量为`wti`。我们需要计算最小物品数量，能恰好组成给定的总量。这不同于[经典背包问题](https://www.geeksforgeeks.org/dynamic-programming-set-10-0-1-knapsack-problem/), 。

**Examples:**

```
Input : W = 100
       val[]  = {1, 30}
       wt[] = {1, 50}
Output : 100
There are many ways to fill knapsack.
1) 2 instances of 50 unit weight item.
2) 100 instances of 1 unit weight item.
3) 1 instance of 50 unit weight item and 50
   instances of 1 unit weight items.
We get maximum value with option 2.

Input : W = 8
       val[] = {10, 40, 50, 70}
       wt[]  = {1, 3, 4, 5}       
Output : 110 
We get maximum value with one unit of
weight 5 and one unit of weight 3.
```

## [Recommended: Please solve it on “**PRACTICE** ” first, before moving on to the solution.](https://practice.geeksforgeeks.org/problems/knapsack-with-duplicate-items/0) 

Its an unbounded knapsack problem as we can use 1 or more instances of any resource. A simple 1D array, say dp[W+1] can be used such that dp[i] stores the maximum value which can achieved using all items and i capacity of knapsack. Note that we use 1D array here which is different from classical knapsack where we used 2D array. Here number of items never changes. We always have all items available.

We can recursively compute dp[] using below formula