----

原文链接：https://www.geeksforgeeks.org/maximum-items-that-can-be-filled-in-k-knapsacks-of-given-capacity/

译者：BING

时间：20190602

----

给定一个整型数组`W[]`包含物品的重量，并且有`K`个容量为`C`的背包，在物品无法被分拆的情况下，找到能放进背包的物品的最大重量。

**例子:**

> **输入 :** w[] = {3, 9, 8}, k = 1, c = 11
> **输出 :** 11
> 要求的子集是： {3, 8}
> 其中 3+8 = 11
>
> **输入 :** w[] = {3, 9, 8}, k = 1, c = 10
> **输出 :** 9

我们使用**动态规划**来解决这个问题。

我们用两个变量来表示DP的状态。

1. `i` – 当前物品的索引。
2. `R` – 每个背包的剩余容量。

现在，如何用一个变量来存储每个背包的剩余容量呢？

我们初始化`R`，$R =  C + C*(C+1) + C*(C+1)^2 + C*(C+1)^3 ..+ C*(C+1)^{(k-1)}$，这会初始化所有的`K`个背包，每个背包容量为`C`。

现在我们需要执行两个查询：

- 从第`j`个背包中读取剩余的空间：$(r/(c+1)^{(j-1)})\%(c+1).$
- 从第`j`个背包的容量减少x：$ r = r – x*(c+1)^{(j-1)}$

现在，每一步我们都有`k+1`个选择：

1. 拒绝索引`i`
2. 将物品`i`放入背包1
3. 将物品`i`放入背包2
4. 将物品`i`放入背包3
5. …

  k+1) 将物品`i`放入背包k

我们选择最大化结果的路径。

下面是上面方法的实现：

```c++
#include <bits/stdc++.h> 
using namespace std; 

// 2维数组存储DP状态
vector<vector<int> > dp; 

// 用2维数组存储状态是否已经求解的标记
vector<vector<bool> > v; 

// 存储变量C的指数的向量
vector<int> exp_c; 

// 计算状态的函数
int FindMax(int i, int r, int w[], 
			int n, int c, int k) 
{ 

	// 基本情况
	if (i >= n) 
		return 0; 

	// 检查状态是否已经求解
	if (v[i][r]) 
    {
        return dp[i][r]; 
    }
    
	// 设置状态已经求解  
	v[i][r] = 1; 
	dp[i][r] = FindMax(i + 1, r, w, n, c, k); 

	// 递归关系
	for (int j = 0; j < k; j++) { 
		int x = (r / exp_c[j]) % (c + 1); 
		if (x - w[i] >= 0) 
			dp[i][r] = max(dp[i][r], w[i] + 
			FindMax(i + 1, r - w[i] * exp_c[j], w, n, c, k)); 
	} 
	// 返回求解的状态
	return dp[i][r]; 
} 

// 初始化全局变量的函数，并找到R的初始值
int PreCompute(int n, int c, int k) 
{ 

	// Resizing the variables 
	exp_c.resize(k); 
	exp_c[0] = 1; 

	for (int i = 1; i < k; i++){ 
		exp_c[i] = (exp_c[i - 1] * (c + 1)); 
	} 
	dp.resize(n); 
	for (int i = 0; i < n; i++){ 
		dp[i].resize(exp_c[k - 1] * (c + 1), 0); 
	} 
	v.resize(n); 
	for (int i = 0; i < n; i++){ 
		v[i].resize(exp_c[k - 1] * (c + 1), 0); 
	} 

	// Variable to store the initial value of R 
	int R = 0; 
	for (int i = 0; i < k; i++){ 
		R += exp_c[i] * c; 
	} 
	return R; 
} 

// 驱动代码
int main() 
{ 
	// 输入数组
	int w[] = { 3, 8, 9 }; 

	// 背包数量和容量
	int k = 1, c = 11; 

	int n = sizeof(w) / sizeof(int); 

	//  执行预计算
	int r = PreCompute(n, c, k); 

	//  找到需要的答案
	cout << FindMax(0, r, w, n, c, k); 

	return 0; 
} 
```

输出:

```
11
```

**时间复杂度 :** $O(N*k*C^k)$.

## 推荐阅读:

- [Printing Items in 0/1 Knapsack](https://www.geeksforgeeks.org/printing-items-01-knapsack/)
- [Unbounded Knapsack (Repetition of items allowed)](https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/)
- [Number of ways to arrange N items under given constraints](https://www.geeksforgeeks.org/number-of-ways-to-arrange-n-items-under-given-constraints/)
- [Maximum subarray sum in O(n) using prefix sum](https://www.geeksforgeeks.org/maximum-subarray-sum-using-prefix-sum/)
- [Maximum size subset with given sum](https://www.geeksforgeeks.org/maximum-size-subset-given-sum/)
- [Maximum value with the choice of either dividing or considering as it is](https://www.geeksforgeeks.org/maximum-value-choice-either-dividing-considering/)
- [Maximum Sum Decreasing Subsequence](https://www.geeksforgeeks.org/maximum-sum-decreasing-subsequence/)
- [Path with maximum average value](https://www.geeksforgeeks.org/path-maximum-average-value/)
- [Maximum path sum in a triangle.](https://www.geeksforgeeks.org/maximum-path-sum-triangle/)
- [Maximum subsequence sum such that no three are consecutive](https://www.geeksforgeeks.org/maximum-subsequence-sum-such-that-no-three-are-consecutive/)
- [Maximum sum alternating subsequence](https://www.geeksforgeeks.org/maximum-sum-alternating-subsequence-sum/)
- [Maximum Sum Subsequence of length k](https://www.geeksforgeeks.org/maximum-sum-subsequence-of-length-k/)
- [Maximum sum Bi-tonic Sub-sequence](https://www.geeksforgeeks.org/maximum-sum-bi-tonic-sub-sequence/)
- [Maximum Sum Increasing Subsequence | DP-14](https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/)
- [Maximum sum such that no two elements are adjacent](https://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/)

END.